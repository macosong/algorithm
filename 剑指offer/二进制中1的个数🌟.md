输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

#### Intuition

这道题的常规思路是，要确定二进制有几个1，可以拿它与1做与运算，若结果为1，那么表示它最右边一位是1，然后再右移一位，继续和1做与运算，最终确定有几个1。这种做法在处理正数和无符号正数时是可行的，时间复杂度$O(len)$，len表示二进制表示位的长度。代码可以如下：

```java
public int NumberOf1(int n) {
    int count = 0;
    while(n != 0){
        if((n & 1) == 1)    ++count;
        n = n >> 1;
    }
    return count;
}
```

但是它的问题在于不能处理负数，负数的补码表示最左边的位都是1，在右移的时候，左边会不断地补1，所以上面的循环是一个死循环，n=0xFFFFFFFF。

因此必须换一个思路来思考。

如果一个数的最右边是1，比如1001，减去1是1000，二者做与运算得到的是1000，结果是吧1001最右边的1变成了0；如果一个数最右边不是1，比如1100，它减去1是1011，再与1100做与运算得到的也是1000，同样是把最右边的1变成了0。

所以可以依据上述思路进行编码，因为每一步实际上就是把最右边的1变成了0，能做几次这样的修改说明就存在几个1，可以看到，这种解法与是否是正负数无关，不会涉及到位的移动。

#### Solution

```java
public class Solution {
    public int NumberOf1(int n) {
        int count = 0;
        while(n != 0){
            count++;
            n = n & (n - 1);
        }
        return count;
    }
}
```



#### Basic

二进制的左移运算$m <<n$表示将二进制m左移n位，最左边的n位将丢弃，且右边补n个0.

二进制的右移运算$m>>n$表示好将二进制m右移n位，最右边的n位丢弃，如果数字是无符号整数，那么左边补n个0；如果m是一个有符号数值且是正数，那么在左边补n个0，如果是负数，那么补n个1。

在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理。正数的补码就是它二进制表示本身；负数的补码是它正数的补码的二进制表示取反在加1的结果。