求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

#### Intuition

本题的整体思路是依次计算从右到左每一位上1出现的次数。

对于个位，1、11、21...每隔10位，出现1次1，计算出现了多少次10，就有多少次1，其次对于除以10余下的部分，如果大于等于1，那么1又出现了一次。所以：

> count(1)=(n/10)*1+(n % 10 >= 1 ? 1 : 0)

对于十位，10，11，12...19共10个数，这10个数每隔100会出现一次，即0-99有10个，100-199有10个等等，所以计算出现了多少次100，假设m次，就有10*m个1出现；对于除以100余下的部分，即0-99之间的数k，如果它小于10，则十位不会有1，若大于19，则也会有10个1，若在10-19之间，则有k-10+1个1出现。所以：

> count(10)=(n/100)*10+(if k > 19 10 else if k < 10 0 else k-10+1)

同样对于百位，有100-199共100个数，这100个数每隔1000会出现一次，即0-999有100个，1000-1999有100个等等，计算出现了多少次1000，假设m，就会有100*m个1出现；对于除以1000余下的部分，即0-999之间的数k，如果它小于100，则百位不会有1，若大于199，则也会有100个1，否则有k-100+1个1出现。所以：

> count(100)=(n/1000)*100+(if k > 199 100 else if k < 100 0 else k-100+1)

通过递推我们可以发现规律

`count(i)=(n/(i*10))*i + (if k > 2 * i - 1 i else if k < i 0 else k - i + 1)`

因此可以依据上述规律写出代码

#### Solution

```java
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        if(n < 0)    return 0;
        int count = 0;
        for(int i = 1 ; i <= n ;  i *= 10){
            int cur = i * 10;
            count += (n / cur ) * i;
            int k = n % cur;
            if(k > (2 * i - 1))    count += i;
            else if (k >= i && k <= (2 * i - 1))    count += (k - i + 1);
        }
        return count;
    }
}
```

